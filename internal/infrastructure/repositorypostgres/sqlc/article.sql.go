// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: article.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countArticles = `-- name: CountArticles :one
SELECT
  COUNT(*) AS count
FROM
  articles
WHERE
  CASE
    WHEN $1::uuid[] IS NULL THEN TRUE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::uuid[] IS NULL THEN TRUE
    WHEN cardinality($2::uuid[]) = 0 THEN TRUE
    ELSE user_id = ANY ($2::uuid[])
  END
  AND CASE
    WHEN $3::text[] IS NULL THEN TRUE
    WHEN cardinality($3::text[]) = 0 THEN TRUE
    ELSE tags && $3::text[]
  END
  AND CASE
    WHEN $4::text = 'exclude' THEN deleted_at IS NULL
    WHEN $4::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $4::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
`

type CountArticlesParams struct {
	IDs     []uuid.UUID
	UserIds []uuid.UUID
	Tags    []string
	Deleted string
}

func (q *Queries) CountArticles(ctx context.Context, arg CountArticlesParams) (int64, error) {
	row := q.db.QueryRow(ctx, countArticles,
		arg.IDs,
		arg.UserIds,
		arg.Tags,
		arg.Deleted,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getArticle = `-- name: GetArticle :one
SELECT
  id, slug, title, thumbnail_id, content, tags, user_id, created_at, updated_at, deleted_at
FROM
  articles
WHERE
  CASE
    WHEN $1::uuid IS NULL THEN TRUE
    WHEN $1::uuid = '00000000-0000-0000-0000-000000000000'::uuid THEN TRUE
    ELSE id = $1::uuid
  END
  AND CASE
    WHEN $2::text IS NULL THEN TRUE
    WHEN $2::text = '' THEN TRUE
    ELSE slug = $2::text
  END
  AND CASE
    WHEN $3::text = 'exclude' THEN deleted_at IS NULL
    WHEN $3::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $3::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
`

type GetArticleParams struct {
	ID      uuid.UUID
	Slug    string
	Deleted string
}

func (q *Queries) GetArticle(ctx context.Context, arg GetArticleParams) (Article, error) {
	row := q.db.QueryRow(ctx, getArticle, arg.ID, arg.Slug, arg.Deleted)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Slug,
		&i.Title,
		&i.ThumbnailID,
		&i.Content,
		&i.Tags,
		&i.UserID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listArticles = `-- name: ListArticles :many
SELECT
  id, slug, title, thumbnail_id, content, tags, user_id, created_at, updated_at, deleted_at
FROM
  articles
WHERE
  CASE
    WHEN $1::uuid[] IS NULL THEN TRUE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::uuid[] IS NULL THEN TRUE
    WHEN cardinality($2::uuid[]) = 0 THEN TRUE
    ELSE user_id = ANY ($2::uuid[])
  END
  AND CASE
    WHEN $3::text[] IS NULL THEN TRUE
    WHEN cardinality($3::text[]) = 0 THEN TRUE
    ELSE tags && $3::text[]
  END
  AND CASE
    WHEN $4::text = 'exclude' THEN deleted_at IS NULL
    WHEN $4::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $4::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
ORDER BY
  created_at DESC
OFFSET $5::integer
LIMIT NULLIF($6::integer, 0)
`

type ListArticlesParams struct {
	IDs     []uuid.UUID
	UserIds []uuid.UUID
	Tags    []string
	Deleted string
	Offset  int32
	Limit   int32
}

func (q *Queries) ListArticles(ctx context.Context, arg ListArticlesParams) ([]Article, error) {
	rows, err := q.db.Query(ctx, listArticles,
		arg.IDs,
		arg.UserIds,
		arg.Tags,
		arg.Deleted,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Article
	for rows.Next() {
		var i Article
		if err := rows.Scan(
			&i.ID,
			&i.Slug,
			&i.Title,
			&i.ThumbnailID,
			&i.Content,
			&i.Tags,
			&i.UserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertArticle = `-- name: UpsertArticle :exec
INSERT INTO articles (
  id,
  slug,
  title,
  thumbnail_id,
  content,
  tags,
  user_id,
  created_at,
  updated_at,
  deleted_at
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  NULLIF($10::timestamptz, '0001-01-01T00:00:00Z'::timestamptz)
)
ON CONFLICT (id) DO UPDATE SET
  slug = EXCLUDED.slug,
  title = EXCLUDED.title,
  thumbnail_id = EXCLUDED.thumbnail_id,
  content = EXCLUDED.content,
  tags = EXCLUDED.tags,
  user_id = EXCLUDED.user_id,
  created_at = EXCLUDED.created_at,
  updated_at = EXCLUDED.updated_at,
  deleted_at = COALESCE(EXCLUDED.deleted_at, articles.deleted_at)
`

type UpsertArticleParams struct {
	ID          uuid.UUID
	Slug        string
	Title       string
	ThumbnailID pgtype.UUID
	Content     string
	Tags        []string
	UserID      uuid.UUID
	CreatedAt   pgtype.Timestamptz
	UpdatedAt   pgtype.Timestamptz
	DeletedAt   pgtype.Timestamptz
}

func (q *Queries) UpsertArticle(ctx context.Context, arg UpsertArticleParams) error {
	_, err := q.db.Exec(ctx, upsertArticle,
		arg.ID,
		arg.Slug,
		arg.Title,
		arg.ThumbnailID,
		arg.Content,
		arg.Tags,
		arg.UserID,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	return err
}
