// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: book.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countBooks = `-- name: CountBooks :one
SELECT
  COUNT(*) AS count
FROM
  books
LEFT JOIN (
  SELECT
    book_id
  FROM
    books_categories
  WHERE
    CASE
      WHEN $1::uuid[] IS NULL THEN TRUE
      WHEN cardinality($1::uuid[]) = 0 THEN TRUE
      ELSE category_id = ANY ($1::uuid[])
    END
  GROUP BY
    book_id
  HAVING
    COUNT(DISTINCT category_id) >= CASE
      WHEN $1::uuid[] IS NULL THEN 0
      WHEN cardinality($1::uuid[]) = 0 THEN 0
      ELSE cardinality($1::uuid[])
    END
) AS category_filter
  ON books.id = category_filter.book_id
WHERE
  CASE
    WHEN $2::uuid[] IS NULL THEN TRUE
    WHEN cardinality($2::uuid[]) = 0 THEN TRUE
    ELSE books.id = ANY ($2::uuid[])
  END
  AND CASE
    WHEN $1::uuid[] IS NULL THEN TRUE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE category_filter.book_id IS NOT NULL
  END
  AND CASE
    WHEN $3::decimal IS NULL THEN TRUE
    WHEN $3::decimal = 0 THEN TRUE
    ELSE books.price >= $3::decimal
  END
  AND CASE
    WHEN $4::decimal IS NULL THEN TRUE
    WHEN $4::decimal = 0 THEN TRUE
    ELSE books.price <= $4::decimal
  END
  AND CASE
    WHEN $5::real IS NULL THEN TRUE
    WHEN $5::real = 0 THEN TRUE
    ELSE books.rating >= $5::real
  END
  AND CASE
    WHEN $6::text = 'exclude' THEN books.deleted_at IS NULL
    WHEN $6::text = 'only' THEN books.deleted_at IS NOT NULL
    WHEN $6::text = 'all' THEN TRUE
    ELSE books.deleted_at IS NULL
  END
`

type CountBooksParams struct {
	CategoryIDs []uuid.UUID
	IDs         []uuid.UUID
	MinPrice    pgtype.Numeric
	MaxPrice    pgtype.Numeric
	Rating      float32
	Deleted     string
}

func (q *Queries) CountBooks(ctx context.Context, arg CountBooksParams) (int64, error) {
	row := q.db.QueryRow(ctx, countBooks,
		arg.CategoryIDs,
		arg.IDs,
		arg.MinPrice,
		arg.MaxPrice,
		arg.Rating,
		arg.Deleted,
	)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createTempTableBooksCategories = `-- name: CreateTempTableBooksCategories :exec
CREATE TABLE temp_books_categories (
  book_id UUID NOT NULL,
  category_id UUID NOT NULL,
  PRIMARY KEY (book_id, category_id)
) ON COMMIT DROP
`

func (q *Queries) CreateTempTableBooksCategories(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempTableBooksCategories)
	return err
}

const createTempTableBooksMedium = `-- name: CreateTempTableBooksMedium :exec
CREATE TABLE temp_books_medium (
  book_id UUID NOT NULL,
  media_id UUID NOT NULL,
  "order" INTEGER NOT NULL,
  is_cover BOOLEAN NOT NULL,
  PRIMARY KEY (book_id, media_id)
) ON COMMIT DROP
`

func (q *Queries) CreateTempTableBooksMedium(ctx context.Context) error {
	_, err := q.db.Exec(ctx, createTempTableBooksMedium)
	return err
}

const getBook = `-- name: GetBook :one
SELECT
  id, title, description, author, price, pages_count, year, publisher, weight, stock_quantity, purchase_count, rating, created_at, updated_at, deleted_at
FROM
  books
WHERE
  books.id = $1
  AND CASE
    WHEN $2::text = 'exclude' THEN deleted_at IS NULL
    WHEN $2::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $2::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
`

type GetBookParams struct {
	ID      uuid.UUID
	Deleted string
}

func (q *Queries) GetBook(ctx context.Context, arg GetBookParams) (Book, error) {
	row := q.db.QueryRow(ctx, getBook, arg.ID, arg.Deleted)
	var i Book
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Description,
		&i.Author,
		&i.Price,
		&i.PagesCount,
		&i.Year,
		&i.Publisher,
		&i.Weight,
		&i.StockQuantity,
		&i.PurchaseCount,
		&i.Rating,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

type InsertTempTableBooksCategoriesParams struct {
	BookID     uuid.UUID
	CategoryID uuid.UUID
}

type InsertTempTableBooksMediumParams struct {
	BookID  uuid.UUID
	MediaID uuid.UUID
	Order   int32
	IsCover bool
}

const listBooks = `-- name: ListBooks :many
SELECT
  books.id, books.title, books.description, books.author, books.price, books.pages_count, books.year, books.publisher, books.weight, books.stock_quantity, books.purchase_count, books.rating, books.created_at, books.updated_at, books.deleted_at
FROM
  books
LEFT JOIN (
  SELECT
    categories.id AS category_id,
    pdb.score(books.id) AS category_score
  FROM books
  INNER JOIN books_categories
    ON books.id = books_categories.book_id
  INNER JOIN categories
    ON books_categories.category_id = categories.id
  WHERE
    CASE
      WHEN $1::text = '' THEN TRUE
      ELSE (
        categories.name ||| $1::text
        AND categories.deleted_at IS NULL
      )
    END
) AS category_scores
  ON books.id = (SELECT bc.book_id FROM books_categories bc WHERE bc.category_id = category_scores.category_id LIMIT 1)
LEFT JOIN (
  SELECT
    book_id
  FROM
    books_categories
  WHERE
    CASE
      WHEN $2::uuid[] IS NULL THEN TRUE
      WHEN cardinality($2::uuid[]) = 0 THEN TRUE
      ELSE category_id = ANY ($2::uuid[])
    END
  GROUP BY
    book_id
  HAVING
    COUNT(DISTINCT category_id) >= CASE
      WHEN $2::uuid[] IS NULL THEN 0
      ELSE cardinality($2::uuid[])
    END
) AS category_filter
  ON books.id = category_filter.book_id
WHERE
  CASE
    WHEN $3::uuid[] IS NULL THEN TRUE
    WHEN cardinality($3::uuid[]) = 0 THEN TRUE
    ELSE books.id = ANY ($3::uuid[])
  END
  AND CASE
    WHEN $1::text = '' THEN TRUE
    ELSE books.title ||| $1::text
      OR books.author ||| $1::text
      OR books.description ||| $1::text
  END
  AND CASE
    WHEN $2::uuid[] IS NULL THEN TRUE
    WHEN cardinality($2::uuid[]) = 0 THEN TRUE
    ELSE category_filter.book_id IS NOT NULL
  END
  AND CASE
    WHEN $4::decimal IS NULL THEN TRUE
    WHEN $4::decimal = 0 THEN TRUE
    ELSE books.price >= $4::decimal
  END
  AND CASE
    WHEN $5::decimal IS NULL THEN TRUE
    WHEN $5::decimal = 0 THEN TRUE
    ELSE books.price <= $5::decimal
  END
  AND CASE
    WHEN $6::real IS NULL THEN TRUE
    WHEN $6::real = 0 THEN TRUE
    ELSE books.rating >= $6::real
  END
  AND CASE
    WHEN $7::text = '' THEN TRUE
    ELSE books.publisher ||| $7::text
  END
  AND CASE
    WHEN $8::integer IS NULL THEN TRUE
    WHEN $8::integer = 0 THEN TRUE
    ELSE books.year = $8::integer
  END
  AND CASE
    WHEN $9::text = 'exclude' THEN books.deleted_at IS NULL
    WHEN $9::text = 'only' THEN books.deleted_at IS NOT NULL
    WHEN $9::text = 'all' THEN TRUE
    ELSE books.deleted_at IS NULL
  END
ORDER BY
  CASE WHEN
    $1::text <> '' THEN pdb.score(books.id) + COALESCE(category_scores.category_score, 0)
  END DESC,
  CASE WHEN
    $10::text = 'asc' THEN books.rating
  END ASC,
  CASE WHEN
    $10::text = 'desc' THEN books.rating
  END DESC,
  CASE WHEN
    $11::text = 'asc' THEN books.price
  END ASC,
  CASE WHEN
    $11::text = 'desc' THEN books.price
  END DESC,
  CASE WHEN
    $12::text = 'asc' THEN books.created_at
  END ASC,
  CASE WHEN
    $12::text = 'desc' THEN books.created_at
  END DESC,
  books.id DESC
OFFSET $13::integer
LIMIT NULLIF($14::integer, 0)
`

type ListBooksParams struct {
	Search      string
	CategoryIDs []uuid.UUID
	IDs         []uuid.UUID
	MinPrice    pgtype.Numeric
	MaxPrice    pgtype.Numeric
	Rating      float32
	Publisher   string
	Year        int32
	Deleted     string
	SortRating  string
	SortPrice   string
	SortRecent  string
	Offset      int32
	Limit       int32
}

func (q *Queries) ListBooks(ctx context.Context, arg ListBooksParams) ([]Book, error) {
	rows, err := q.db.Query(ctx, listBooks,
		arg.Search,
		arg.CategoryIDs,
		arg.IDs,
		arg.MinPrice,
		arg.MaxPrice,
		arg.Rating,
		arg.Publisher,
		arg.Year,
		arg.Deleted,
		arg.SortRating,
		arg.SortPrice,
		arg.SortRecent,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Book
	for rows.Next() {
		var i Book
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Description,
			&i.Author,
			&i.Price,
			&i.PagesCount,
			&i.Year,
			&i.Publisher,
			&i.Weight,
			&i.StockQuantity,
			&i.PurchaseCount,
			&i.Rating,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooksCategories = `-- name: ListBooksCategories :many
SELECT
  book_id, category_id
FROM
  books_categories
WHERE
  CASE
    WHEN $1::uuid[] IS NULL THEN TRUE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE book_id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::uuid[] IS NULL THEN TRUE
    WHEN cardinality($2::uuid[]) = 0 THEN TRUE
    ELSE category_id = ANY ($2::uuid[])
  END
ORDER BY
  book_id ASC,
  category_id ASC
`

type ListBooksCategoriesParams struct {
	BookIDs     []uuid.UUID
	CategoryIDs []uuid.UUID
}

func (q *Queries) ListBooksCategories(ctx context.Context, arg ListBooksCategoriesParams) ([]BooksCategory, error) {
	rows, err := q.db.Query(ctx, listBooksCategories, arg.BookIDs, arg.CategoryIDs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BooksCategory
	for rows.Next() {
		var i BooksCategory
		if err := rows.Scan(&i.BookID, &i.CategoryID); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listBooksMedium = `-- name: ListBooksMedium :many
SELECT
  book_id, media_id, "order", is_cover
FROM
  books_medium
WHERE
  CASE
    WHEN $1::uuid[] IS NULL THEN TRUE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE book_id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::uuid[] IS NULL THEN TRUE
    WHEN cardinality($2::uuid[]) = 0 THEN TRUE
    ELSE media_id = ANY ($2::uuid[])
  END
  AND CASE
    WHEN $3::boolean IS NULL THEN TRUE
    ELSE is_cover = $3::boolean
  END
ORDER BY
  book_id ASC,
  media_id ASC
`

type ListBooksMediumParams struct {
	BookIDs  []uuid.UUID
	MediaIds []uuid.UUID
	IsCover  bool
}

func (q *Queries) ListBooksMedium(ctx context.Context, arg ListBooksMediumParams) ([]BooksMedium, error) {
	rows, err := q.db.Query(ctx, listBooksMedium, arg.BookIDs, arg.MediaIds, arg.IsCover)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []BooksMedium
	for rows.Next() {
		var i BooksMedium
		if err := rows.Scan(
			&i.BookID,
			&i.MediaID,
			&i.Order,
			&i.IsCover,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const mergeBooksCategoriesFromTemp = `-- name: MergeBooksCategoriesFromTemp :exec
MERGE INTO books_categories AS target
USING temp_book_categories AS source
  ON target.book_id = source.book_id
  AND target.category_id = source.category_id
WHEN NOT MATCHED THEN
  INSERT (
    book_id,
    category_id
  )
  VALUES (
    source.book_id,
    source.category_id
  )
WHEN NOT MATCHED BY SOURCE
  AND target.book_id = (SELECT DISTINCT book_id FROM temp_book_categories) THEN
  DELETE
`

func (q *Queries) MergeBooksCategoriesFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, mergeBooksCategoriesFromTemp)
	return err
}

const mergeBooksMediumFromTemp = `-- name: MergeBooksMediumFromTemp :exec
MERGE INTO books_medium AS target
USING temp_books_medium AS source
  ON target.book_id = source.book_id
  AND target.media_id = source.media_id
WHEN MATCHED THEN
  UPDATE SET
    "order" = source."order",
    is_cover = source.is_cover
WHEN NOT MATCHED THEN
  INSERT (
    book_id,
    media_id,
    "order",
    is_cover
  )
  VALUES (
    source.book_id,
    source.media_id,
    source."order",
    source.is_cover
  )
WHEN NOT MATCHED BY SOURCE
  AND target.book_id = (SELECT DISTINCT book_id FROM temp_books_media) THEN
  DELETE
`

func (q *Queries) MergeBooksMediumFromTemp(ctx context.Context) error {
	_, err := q.db.Exec(ctx, mergeBooksMediumFromTemp)
	return err
}

const upsertBook = `-- name: UpsertBook :exec
INSERT INTO books (
  id,
  title,
  description,
  author,
  price,
  pages_count,
  year,
  publisher,
  weight,
  stock_quantity,
  purchase_count,
  rating,
  created_at,
  updated_at,
  deleted_at
)
VALUES (
  $1,
  $2,
  $3,
  $4,
  $5,
  $6,
  $7,
  $8,
  $9,
  $10,
  $11,
  $12,
  $13,
  $14,
  NULLIF($15::timestamptz, '0001-01-01T00:00:00Z'::timestamptz)
)
ON CONFLICT (id) DO UPDATE SET
  title = EXCLUDED.title,
  description = EXCLUDED.description,
  author = EXCLUDED.author,
  price = EXCLUDED.price,
  pages_count = EXCLUDED.pages_count,
  year = EXCLUDED.year,
  publisher = EXCLUDED.publisher,
  weight = EXCLUDED.weight,
  stock_quantity = EXCLUDED.stock_quantity,
  purchase_count = EXCLUDED.purchase_count,
  rating = EXCLUDED.rating,
  created_at = EXCLUDED.created_at,
  updated_at = EXCLUDED.updated_at,
  deleted_at = COALESCE(EXCLUDED.deleted_at, books.deleted_at)
`

type UpsertBookParams struct {
	ID            uuid.UUID
	Title         string
	Description   *string
	Author        string
	Price         pgtype.Numeric
	PagesCount    int32
	Year          int32
	Publisher     string
	Weight        pgtype.Numeric
	StockQuantity int32
	PurchaseCount int32
	Rating        float32
	CreatedAt     pgtype.Timestamptz
	UpdatedAt     pgtype.Timestamptz
	DeletedAt     pgtype.Timestamptz
}

func (q *Queries) UpsertBook(ctx context.Context, arg UpsertBookParams) error {
	_, err := q.db.Exec(ctx, upsertBook,
		arg.ID,
		arg.Title,
		arg.Description,
		arg.Author,
		arg.Price,
		arg.PagesCount,
		arg.Year,
		arg.Publisher,
		arg.Weight,
		arg.StockQuantity,
		arg.PurchaseCount,
		arg.Rating,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.DeletedAt,
	)
	return err
}
