// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: media.sql

package sqlc

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const countMedium = `-- name: CountMedium :one
SELECT
  COUNT(*)
FROM
  media
WHERE
  CASE
    WHEN $1::uuid[] IS NULL THEN TRUE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::text = 'exclude' THEN deleted_at IS NULL
    WHEN $2::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $2::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
`

type CountMediumParams struct {
	IDs     []uuid.UUID
	Deleted string
}

func (q *Queries) CountMedium(ctx context.Context, arg CountMediumParams) (int64, error) {
	row := q.db.QueryRow(ctx, countMedium, arg.IDs, arg.Deleted)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getMedia = `-- name: GetMedia :one
SELECT
  id, url, alt_text, created_at, deleted_at
FROM
  media
WHERE
  id = $1
  AND CASE
    WHEN $2::text = 'exclude' THEN deleted_at IS NULL
    WHEN $2::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $2::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
`

type GetMediaParams struct {
	ID      uuid.UUID
	Deleted string
}

func (q *Queries) GetMedia(ctx context.Context, arg GetMediaParams) (Medium, error) {
	row := q.db.QueryRow(ctx, getMedia, arg.ID, arg.Deleted)
	var i Medium
	err := row.Scan(
		&i.ID,
		&i.URL,
		&i.AltText,
		&i.CreatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const listMedium = `-- name: ListMedium :many
SELECT
  id, url, alt_text, created_at, deleted_at
FROM
  media
WHERE
  CASE
    WHEN $1::uuid[] IS NULL THEN TRUE
    WHEN cardinality($1::uuid[]) = 0 THEN TRUE
    ELSE id = ANY ($1::uuid[])
  END
  AND CASE
    WHEN $2::text = 'exclude' THEN deleted_at IS NULL
    WHEN $2::text = 'only' THEN deleted_at IS NOT NULL
    WHEN $2::text = 'all' THEN TRUE
    ELSE deleted_at IS NULL
  END
ORDER BY
  id ASC
OFFSET $3::integer
LIMIT NULLIF($4::integer, 0)
`

type ListMediumParams struct {
	IDs     []uuid.UUID
	Deleted string
	Offset  int32
	Limit   int32
}

func (q *Queries) ListMedium(ctx context.Context, arg ListMediumParams) ([]Medium, error) {
	rows, err := q.db.Query(ctx, listMedium,
		arg.IDs,
		arg.Deleted,
		arg.Offset,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Medium
	for rows.Next() {
		var i Medium
		if err := rows.Scan(
			&i.ID,
			&i.URL,
			&i.AltText,
			&i.CreatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const upsertMedia = `-- name: UpsertMedia :exec
INSERT INTO media (
  id,
  url,
  alt_text,
  created_at,
  deleted_at
)
VALUES (
  $1,
  $2,
  NULLIF($3::text, ''),
  $4,
  NULLIF($5::timestamptz, '0001-01-01T00:00:00Z'::timestamptz)
)
ON CONFLICT (id) DO UPDATE SET
  url = EXCLUDED.url,
  alt_text = EXCLUDED.alt_text,
  created_at = EXCLUDED.created_at,
  deleted_at = COALESCE(EXCLUDED.deleted_at, media.deleted_at)
`

type UpsertMediaParams struct {
	ID        uuid.UUID
	URL       string
	AltText   string
	CreatedAt pgtype.Timestamptz
	DeletedAt pgtype.Timestamptz
}

func (q *Queries) UpsertMedia(ctx context.Context, arg UpsertMediaParams) error {
	_, err := q.db.Exec(ctx, upsertMedia,
		arg.ID,
		arg.URL,
		arg.AltText,
		arg.CreatedAt,
		arg.DeletedAt,
	)
	return err
}
